# JSONG

This is the repo for the JSONG editor framework. The goal of this system is to provide a simple way to create in-situ editor extensions for in-browser editors of JSON domain specific languages.
The basic dependencies of this system are code mirror (which we wrap) and react (which we use as means to specify the extensions).
Additionally a number of libraries have been forked to support this work, see src/lib/vendor (this won't matter to you, its more an acknowledgement of work).

INSTALLATION INSTRUCTIONS TODO

Quick start example usage

```tsx
import React, { useState } from "react";

import Editor from "../components/Editor";
import standardBundle from "../projections/standard-bundle";

const exampleData = `{
    "a": {
      "b": [1, 2, 3],
      "c": true,
    },
    "d": null,
    "e": [{ "f": 4, "g": 5 }],
    "I": "example",
  }`;

function SimpleExample() {
  const [currentCode, setCurrentCode] = useState(exampleData);

  return (
    <Editor
      schema={{}}
      code={currentCode}
      onChange={(x) => setCurrentCode(x)}
      projections={Object.values(standardBundle)}
    />
  );
}
```

## Component

The library consists of a single component it has a type like

Editor

- schema: json schema
- code: string
- onChange: (code: string) => void
- projections: Projection[], see below
- ...

## Projections

The central design abstraction in JSONG are projections. These are lightweight ways to modify the text within the editor to fit your goals.

There are four types of projections.

### Tooltip Projection/ Full Tooltip Projection

The two types of projections are closely related, both of them create a menu item that will appear in the tooltip or the dock (depending on what the user wants in a given moment).
Here are the types for each of the objects

```tsx
{
  name: string;
  projection: (props: ProjectionProps) => JSX.Element;
  query: ProjectionQuery;
  type: "tooltip";
}
```

```tsx
{
  name: string;
  projection: (props: ProjectionProps) => JSX.Element;
  query: ProjectionQuery;
  type: "full-tooltip";
}
```

See [Queries](asddsa) below for an example of the query system.
The name describe which heading the projection will be grouped into.
The projection creates the specific element that inserted into the menu, it expects a function that returns a react component. It gets props like

```tsx
interface ProjectionProps {
  currentValue: any;
  cursorPositions: any[];
  diagnosticErrors: Diagnostic[];
  fullCode: string;
  keyPath: (string | number)[];
  node: SyntaxNode;
  setCode: (code: string) => void;
  typings: any[];
}
```

TODODODODODOD
SyntaxNode is the AST node generated by code mirror (see [their docs](ASDDSA) for more details).
keyPath is the access path for the value in the json object. Current value is

### Inline Projection

TODODODODODOD

```tsx
{
  hasInternalState: boolean;
  mode: "replace" | "prefix" | "suffix" | "replace-multiline";
  projection: (props: ProjectionProps) => JSX.Element;
  query: ProjectionQuery;
  type: "inline";
}
```

### Highlight Projection

This simplest of the projections allows you to add a css class to whatever elements in the editor you might wish to. See examples/TraceryExample for example usage.

```tsx
{
  class: string;
  query: ProjectionQuery;
  type: "highlight";
}
```

## Queries

A critical part of the projection system are the queries. These small functions allow the system to check when and where each component should be inserted.

These come in a variety of flavors

- **Index Queries**:

```ts
{ type: "index"; query: (number | string)[] }
```

- **Regex Queries**:

```ts
{
  type: "regex";
  query: RegExp;
}
```

- **Value Queries**:

```ts
{ type: "value"; query: string[] }
```

- **Schema Queries**:

```ts
{ type: "schemaMatch"; query: string[] }
```

- **Node Type Queries**:
  These queries allow you to check for a given AST node type. The JSON AST includes the following symbols: `String`, `Number`, `True`, `False`, `Null`, `Object`, `Array`, `Property`, `PropertyName`, `{`, `},` `[`, `]`, and `âš ` (which describes parse errors).

```ts
{ type: "nodeType"; query: NodeType[] };
```

- **Function Queries**:
  If none of these work for you there is also a function query type. This is obviously the most expensive to run, so should be avoided where possible.

```ts
{
  type: "function";
  query: (value: string, nodeType: NodeType) => boolean;
}
```
